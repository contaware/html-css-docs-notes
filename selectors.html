<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSS selectors</title>
    <style>
        /* Universal selector */
        * {}

        /* Tag selector */
        div {}

        /* Class selector */
        .item {}

        /* Classes selector (must have both classes) */
        .first.item {}

        /* ID selector */
        #myid {}

        /* Attribute selector */
        [myattr] {}
        [type="text"] {}
        [type^="te"] {}  /* begging of value is "te" */
        [type$="xt"] {}  /* end of value is "xt" */
        [type*="ex"] {}  /* substring of value is "ex" */

        /* Multiple items selector 
           Note: there is also :where() which is functionally identical to 
                 :is() but with a zero specificity compared to :is() which 
                 has the specificity of its most specific argument. */
        li.first, li.last {}
        li:is(.first, .last) {}   /* equivalent to the above */
        .mycls strong, .mycls em {}
        .mycls :is(strong, em) {} /* equivalent to the above */

        /* Child selector */
        ul > li {}

        /* Descendant selector */        
        ul strong {}

        /* Next-sibling selector, the two elements must be next to 
           each other, and they must share the same parent. */  
        div + p {} /* selects <p> directly after <div> */

        /* Subsequent-sibling selector, some elements can be in between, 
           but the two elements must share the same parent. */
        div ~ span {} /* selects <span> coming after <div> */

        /* The :root pseudo-class represents an element that is the root 
           of the document. In HTML, this is always the html element.
           One technical difference between them is that :root, being a 
           pseudo-class, has a greater specificity than html. */

        /* Pseudo-class selectors which select an entire element */
        li:first-child {}   /* matches if <li> is the first child */
        li:nth-child(2) {}  /* matches if <li> is the second child */
        li:nth-child(2n) {} /* matches if <li> is an even child */
        li:last-child {}    /* matches if <li> is the last child */  

        /* Pseudo-class selectors which select a state of an element */
        li:hover {}
        input[type="text"]:focus {outline: 2px dashed orange}
        input[type="checkbox"]:checked {box-shadow: 0px 0px 5px 2px green}
        input[type="email"]:valid {outline: 2px solid green}
        input[type="email"]:invalid {outline: 2px dashed red}
        input[type="number"]:in-range {color: white; background: green}
        div:empty {outline: 2px solid deeppink; height: 1em}

        /* The :not() pseudo-class selector
           It represents elements that do not match the selectors 
           in the comma-separated list.
           In the example below, it does not match li elements with 
           a class of .first, it also does not match li elements 
           with a class of .last, and it does not match elements 
           with both classes. That's the exact opposite of: 
           li.first, li.last {}
        */
        li:not(.first, .last) {}
        li:not(.first):not(.last) {} /* equivalent to the above */

        /* The :has() pseudo-class selector
           If you want to select the first element instead of the last one, 
           write down the selector line meant for the last element, 
           and move everything after the first element into a :has(). 
           For example ul > li becomes ul:has(> li) */
        ul:has(li) {}      /* select <ul> which has <li> as descendant */
        ul:has(> li) {}    /* select <ul> which has <li> as direct child */
        div:has(+ p) {}    /* select <div> which has <p> as next-sibling */
        div:has(~ span) {} /* select <div> which has <span> as sibling */

        /* Pseudo-element selectors
           - Use two colons to distinguish pseudo-elements from 
             pseudo-classes, one colon is the old syntax. 
           - Pseudo-elements are only allowed at the end of a selector line.
        */
        
        /* Pseudo-element selectors which let you style a specific part of 
           the selected element. */
        p.mycls::first-letter {font-size: 200%} /* only for block elements */
        p.mycls::first-line {color: red}      /* only for block elements */

        /* Pseudo-element selectors created as first/last children of the 
           selected element.
           - Can add content only to tags that have a content.
           - The content property must always be provided.
        */
        div#myid:hover::before {
            /* Concatenate attr() with text by separating with spaces */
            content: 'This is ' attr(myattr) '! '
        }
        p.mycls::after {
            content: '';
            display: inline-block;
            width: 12px;
            height: 12px;
            background: red;
        }
    </style>
</head>
<body>
    <h2>CSS Syntax</h2>
    <ul>
        <li>A CSS rule consists of a selector and a block of declarations:<br><code>selector {property1: value1; property2: value2;}</code><br>
        The CSS selector is used to target the HTML elements that we want to style. The last declaration of a block doesn't need to be terminated by a semicolon.</li>
        <li>For a CSS inline style which is a CSS rule written in the <code>style</code> attribute of a HTML tag, the selector part is not present and the curly braces around the declaration block are omitted.</li>
        <li>In CSS, classes and IDs can contain only the characters [a-zA-Z0-9_-]. They cannot start with a digit, with <code>--</code>, or with a <code>-</code> followed by a digit.</li>
    </ul>

    <h2>Precedence</h2>
    <ul>
        <li><strong>Overriding</strong> means that a given CSS declaration wins over another one.</li>
        <li>A point system is used to determine the precedence of a CSS declaration. Each CSS declaration gets points assigned in different categories, those are ordered from <strong>strongest</strong> to <strong>weakest</strong>:
        <ol>
            <li>If a CSS declaration has <code>!important</code> appended to its value, give a point to this category.</li>
            <li>If a CSS declaration is written in the <code>style</code> attribute of a HTML tag, give a point to this category.</li>
            <li>For each ID in the CSS selector, add a point to this category.</li>
            <li>For each class/pseudo-class/attribute-selector in the CSS selector, add a point to this category.</li>
            <li>For each element/pseudo-element in the CSS selector, add a point to this category.</li>
        </ol>
        A comparison of two CSS declarations starts from the strongest category, if the points match, the next category is checked and so on. As soon as one of the two CSS declarations has more points in a category, it wins.<br>Note: the term <em>selector specificity</em> refers to the last three categories mentioned above.</li>
        <li>If there is no winner from the above comparison, then the CSS declaration declared last wins. From that, it's clear that the order of <code>&lt;style&gt;..&lt;/style&gt;</code> and <code>&lt;link&gt;</code> in an HTML document matters.</li>
    </ul>

    <h2>Example for the selectors found in <code>&lt;style&gt;</code> tag</h2>
    <div id="myid" myattr="great">This is a div.</div>
    <p class="mycls">This is a paragraph, <strong>color</strong> changes back to the default when wrapping.</p>
    <span>This is a span.</span><br>
    <input type="text" placeholder="Focus for outline"><br>
    <input type="checkbox" id="check"><label for="check">Check for box shadow</label><br>
    <input type="email" placeholder="Enter a valid email" required><br>
    <input type="number" min="1" max="5" value="1">
    <ul>
        <li class="first item"><strong>Item 1</strong></li>
        <li class="item">Item 2</li>
        <li class="item">Item 3</li>
        <li class="last item">Item 4</li>
    </ul>
    <p class="mycls">Next follows an <em>empty</em> &lt;div&gt;:</p>
    <div></div>
</body>
</html>